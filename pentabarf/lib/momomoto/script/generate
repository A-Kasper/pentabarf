#!/usr/bin/env ruby

require 'yaml'
require 'rubygems'
require 'postgres'

if ARGV.length < 2
  puts "Usage: #{$0} <table> <domain>"
  exit
end

config = YAML.load_file('../../config/database.yml')['development']
connection = PGconn.connect( config['host'], config['port'], nil, nil,
                             config['database'], config['username'], config['password'])

def udt_name_to_class( udt_name, properties )
  case udt_name
    when 'bool'           then 'Bool'
    when 'bytea'          then 'Bytea'
    when 'bpchar'         then 'Char'
    when 'date'           then 'Date'
    when 'inet'           then 'Inet'
    when 'int2'           then 'Smallint'
    when 'int4'           then 'Integer'
    when 'int8'           then 'Integer'
    when 'interval'       then 'Interval'
    when 'numeric'        then 'Numeric'
    when 'varchar'        then 'Varchar'
    when 'text'           then 'Text'
    when 'time'           then 'Time'
    when 'timetz'         then
      properties[:with_timezone] = true
      'Time'
    when 'timestamp'      then 'Datetime'
    when 'timestamptz'    then
      properties[:with_timezone] = true
      'Datetime'
    else raise "Unsupported Datatype #{udt_name}"
  end
end

table = ARGV[0]
domain = ARGV[1]
database = 'pentabarf'

fields = connection.exec(
 "SELECT column_name,
        column_default,
        character_maximum_length,
        numeric_precision,
        numeric_precision_radix,
        numeric_scale,
        udt_name,
        is_nullable
   FROM information_schema.columns
   WHERE table_catalog = '#{database}' AND table_name = '#{table}'
   ORDER BY ordinal_position;" ).entries

puts "module Momomoto"
puts "  class #{table.capitalize} < Base"
puts "    def initialize"
puts "      super"
puts "      @domain = '#{domain}'"
puts "      @fields = {"
for i in 0..(fields.length - 1) do
  properties = {}
  properties[:not_null] = true if fields[i][7] == 'NO'
  properties[:length] = fields[i][2].to_i if fields[i][2].to_i != 0
  pk = connection.exec("SELECT column_name FROM information_schema.constraint_column_usage WHERE table_catalog = '#{database}' AND table_name = '#{table}' AND column_name = '#{fields[i][0]}' AND constraint_name = '#{table}_pkey'").entries
  properties[:primary_key] = true if pk.length > 0
  properties[:serial] = true if fields[i][1] && fields[i][1].match( /^nextval/ )
  properties[:default] = true if fields[i][1].to_s != ''

  puts "        :#{fields[i][0]} => Datatype::#{udt_name_to_class(fields[i][6],properties)}.new( #{properties.inspect} )#{',' if i < (fields.length - 1 )}"
end
puts "      }"
puts "    end"
puts "  end"
puts "end"
